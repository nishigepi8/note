## 前言

最近入手了 Luckfox Pico Max 这块小开发板，基于 Rockchip RV1106 芯片，性价比很高，特别适合做一些边缘端的视频项目。我的目标是实现一个真正的点对点（P2P）视频直播方案：摄像头采集的视频能直接从一台设备传到另一台设备，尽量不依赖中心服务器，只在必要时用中继。这样既省流量，又低延迟，还能保持隐私。

我的实现思路是：用 C 语言负责视频采集和 H.264 硬件编码（发挥芯片优势），Golang 负责 P2P 连接和数据传输，两者通过 Unix Domain Socket 高效互通。整个方案简单、模块化，嵌入式环境下编译部署也友好。下面分享我的技术选型、实现细节和一些心得。








> **硬件说明**：Luckfox Pico Max 实物图，带摄像头和网口的那款特别适合视频应用

## 核心技术背景

### Rockchip RV1106 芯片简介
Luckfox Pico Max 的核心是 Rockchip RV1106：单核 ARM Cortex-A7 @1.2GHz + RISC-V 协处理器，集成 1 TOPS NPU，内置 ISP 支持最高 4M@30fps 摄像头输入，256MB DDR2 内存。芯片对 H.264 编码有硬件加速，功耗低、体积小，非常适合低成本的 IPCamera 或边缘 AI 视频设备。




> **芯片架构**：RV1106 芯片架构示意

### STUN 和 TURN：P2P 的“穿墙”利器
大多数家庭/办公网络都在 NAT 后面，直接 P2P 连接很难建立。这时就需要：

- **STUN**（Session Traversal Utilities for NAT）：让设备发现自己的公网 IP 和端口，尝试直接打洞连接。大多数情况下都能成功，零中继、零额外流量。
- **TURN**（Traversal Using Relay for NAT）：当对称 NAT 或防火墙太严格时，退化为中继服务器转发数据。虽然有延迟，但保证可用性。

我用的是 WebRTC 的 ICE（Interactive Connectivity Establishment）机制，它会自动优先尝试 STUN 直连，失败再 fallback 到 TURN。








> **连接流程**：典型 WebRTC P2P 连接流程，包括 STUN/TURN

## 我的实现架构

整个系统分成两个独立进程，通过 Unix Domain Socket（本地高效 IPC）通信：

### 1. C 语言模块：视频采集 + 硬件编码
- 使用 Rockchip SDK 的 VENC 接口直接从摄像头抓取原始帧。
- 利用芯片硬件 H.264 编码器压缩（效率高、CPU 占用低）。
- 编码后的 NALU 单元直接写入 Unix Domain Socket，像管道一样源源不断输出。

这一部分专注“生产”视频流，代码简洁，性能极致。

### 2. Golang 模块：P2P 连接 + 流转发
- 使用优秀的开源库 [Pion WebRTC](https://github.com/pion/webrtc)（纯 Go 实现，无需 CGO）。
- 通过 ICE 自动处理 STUN/TURN，快速建立 DataChannel 或 Media Track。
- 从 Unix Domain Socket 读取 H.264 裸流，封装成 RTP 包，通过 P2P 通道发送。

接收端逻辑对称：Golang 收到数据后，可直接喂给 ffplay/VLC 解码播放，或转发到浏览器。

整体数据流：**摄像头 → C 编码 → Unix Socket → Golang → P2P 通道 → 对端**




## 为什么选择 C + Golang 混合，而不是纯 C 或纯 Go？

这是我思考最多的地方：

- 如果全用 C：视频采集编码简单，但实现完整 WebRTC 栈（ICE、STUN、DTLS、SCTP 等）非常复杂，嵌入式交叉编译依赖地狱。
- 如果全用 Go：Pion 库很棒，但 Go 在 Luckfox 上访问底层摄像头和硬件编码器需要 CGO，编译麻烦，性能也打折。
- **混合方案最佳**：C 专注底层硬件（发挥 RV1106 优势），Go 专注上层网络（Pion 生态成熟）。两者通过本地 Socket 解耦，开发效率高、维护性好。

这也是我个人偏好的体现：**用最合适的语言做最合适的事**，而不是一刀切。

## 测试效果与建议

我本地和跨运营商网络测试过：
- 同局域网：几乎零延迟，直连成功率 100%。
- 跨 NAT：用 Google 公共 STUN（stun.l.google.com:19302）大多直连成功，偶尔 fallback TURN。
- 画质：720p@30fps 流畅，码率控制在 300-500kbps。

实际运行截图（浏览器端接收）：

> **测试效果**：实际运行截图（浏览器端接收），硬件实物 + 测试界面

建议：
- 先本地测试 ICE 连接。
- 如需 TURN，可自搭 Coturn 或用公共服务。
- 信令服务器（用于交换 SDP）可以用简单 WebSocket，我用了 Go 的 gorilla/websocket。
- 未来可扩展：添加 DTLS 加密、AI 目标检测（用 NPU）等。

## 技术难点与解决方案

### 1. H.264 NALU 封装

H.264 编码后的数据是 NALU（Network Abstraction Layer Unit）单元，需要正确分割和封装：

- **关键帧（IDR）**：必须完整传输，丢失会导致无法解码后续帧
- **P 帧**：依赖前面的帧，可以容忍少量丢失
- **RTP 封装**：每个 NALU 封装成一个 RTP 包，大 NALU 需要分片（FU-A）

### 2. 网络穿透成功率

实际测试中发现：
- **同网段**：100% 直连成功
- **不同运营商**：约 70% 可以直连，30% 需要 TURN 中继
- **对称 NAT**：几乎都需要 TURN

**优化建议**：部署自己的 TURN 服务器（如 Coturn），可以提升穿透成功率。

### 3. 延迟控制

- **编码延迟**：硬件编码器有缓冲，约 30-50ms
- **网络延迟**：直连 <50ms，TURN 中继 100-200ms
- **解码延迟**：浏览器端解码，约 20-30ms

**总延迟**：最佳情况 <100ms，中继情况 200-300ms，基本满足实时需求。

## 性能测试数据

在我的测试环境中（720p@30fps，码率 500kbps）：

| 场景 | 延迟 | CPU 占用 | 内存占用 | 网络带宽 |
|------|------|----------|----------|----------|
| 同局域网直连 | 50-80ms | 15% | 60MB | 500kbps |
| 跨 NAT 直连 | 100-150ms | 18% | 65MB | 500kbps |
| TURN 中继 | 200-300ms | 20% | 70MB | 500kbps |

## 实用资源

- **H.264 流写入 Socket 工具**：[下载链接](https://zfile.ga666666.cn/directlink/1/h264_to_pipe)
- **Mac 下调试 Luckfox IP 的 MQTT 小工具**：[下载链接](https://zfile.ga666666.cn/directlink/1/mqtt_client)（开机上报 IP 到公共 broker，超级方便）

## 未来改进方向

1. **音频支持**：添加音频采集和编码，实现完整的音视频通话
2. **多路流**：支持同时传输多路视频流（如主码流+子码流）
3. **AI 增强**：利用 RV1106 的 NPU 进行目标检测、人脸识别等
4. **录制功能**：本地录制视频流，支持回放
5. **Web 管理界面**：通过 Web 界面配置参数、查看状态

## 总结

这个方案成本低（板子不到 100 元）、灵活性强，适合 DIY 监控、远程查看等场景。通过 C + Golang 的混合架构，既发挥了硬件优势，又利用了成熟的网络库，是一个很好的实践案例。

**关键收获**：
- 理解了 P2P 穿透的原理和局限性
- 掌握了 H.264 编码和 RTP 封装的细节
- 学会了在嵌入式环境下进行音视频开发

如果你也在玩 Luckfox 或类似嵌入式视频项目，欢迎交流，一起优化！